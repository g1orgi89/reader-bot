/**
 * Enhanced Quote Handler with beautiful confirmation and UI for Reader bot
 * @file telegram/handlers/modernQuoteHandler.js
 * üé® VISUAL UX: Beautiful quote cards, elegant confirmations
 * üìñ READER THEME: Book-focused quote processing with Anna Busel persona
 */

const logger = require('../../server/utils/logger');
const { UserProfile, Quote } = require('../../server/models');
const claudeService = require('../../server/services/claude');

/**
 * @typedef {Object} QuoteProcessingResult
 * @property {boolean} success - Whether processing succeeded
 * @property {Object} quote - Processed quote object
 * @property {Object} analysis - AI analysis results
 * @property {Array} achievements - Any new achievements unlocked
 */

/**
 * @class ModernQuoteHandler
 * @description Modern quote handler with beautiful UI and enhanced processing
 */
class ModernQuoteHandler {
  constructor() {
    this.maxQuotesPerDay = 10;
    this.maxQuoteLength = 1000;
    this.processingStates = new Map(); // Track processing states
    
    // Quote templates for beautiful responses
    this.responseTemplates = [
      {
        pattern: 'author_quote',
        templates: [
          '‚ú® –ü—Ä–µ–∫—Ä–∞—Å–Ω–∞—è —Ü–∏—Ç–∞—Ç–∞! {author} —É–º–µ–µ—Ç –Ω–∞—Ö–æ–¥–∏—Ç—å –≥–ª—É–±–∏–Ω—É –≤ –ø—Ä–æ—Å—Ç—ã—Ö —Å–ª–æ–≤–∞—Ö.',
          'üìñ –ó–∞–º–µ—á–∞—Ç–µ–ª—å–Ω—ã–π –≤—ã–±–æ—Ä! {author} - –æ–¥–∏–Ω –∏–∑ –º–æ–∏—Ö –ª—é–±–∏–º—ã—Ö –∞–≤—Ç–æ—Ä–æ–≤.',
          'üí´ –û—á–µ–Ω—å –≥–ª—É–±–æ–∫–æ! –≠—Ç–∞ –º—ã—Å–ª—å {author} –æ—Å–æ–±–µ–Ω–Ω–æ –∞–∫—Ç—É–∞–ª—å–Ω–∞.',
          'üåü –°–æ—Ö—Ä–∞–Ω–∏–ª–∞ –≤ –≤–∞—à –ª–∏—á–Ω—ã–π –¥–Ω–µ–≤–Ω–∏–∫. {author} –≤—Å–µ–≥–¥–∞ –≤–¥–æ—Ö–Ω–æ–≤–ª—è–µ—Ç!'
        ]
      },
      {
        pattern: 'no_author_quote',
        templates: [
          'üí≠ –ü—Ä–µ–∫—Ä–∞—Å–Ω–∞—è —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–∞—è –º—ã—Å–ª—å! –ì–ª—É–±–æ–∫–∏–µ —Ä–∞–∑–º—ã—à–ª–µ–Ω–∏—è.',
          'üå± –ó–∞–º–µ—á–∞—Ç–µ–ª—å–Ω–æ–µ –Ω–∞–±–ª—é–¥–µ–Ω–∏–µ! –í–∞—à–∏ –º—ã—Å–ª–∏ –æ—á–µ–Ω—å —Ü–µ–Ω–Ω—ã.',
          '‚ú® –ú—É–¥—Ä—ã–µ —Å–ª–æ–≤–∞! –°–æ—Ö—Ä–∞–Ω–∏–ª–∞ –≤ –≤–∞—à –¥–Ω–µ–≤–Ω–∏–∫.',
          'üí° –û—Ç–ª–∏—á–Ω–æ–µ —Ä–∞–∑–º—ã—à–ª–µ–Ω–∏–µ! –°–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ –∏–Ω—Å–∞–π—Ç—ã –æ—Å–æ–±–µ–Ω–Ω–æ –≤–∞–∂–Ω—ã.'
        ]
      }
    ];

    // Category emojis for beautiful display
    this.categoryEmojis = {
      '–°–∞–º–æ—Ä–∞–∑–≤–∏—Ç–∏–µ': 'üå±',
      '–õ—é–±–æ–≤—å': '‚ù§Ô∏è',
      '–§–∏–ª–æ—Å–æ—Ñ–∏—è': 'ü§î',
      '–ú–æ—Ç–∏–≤–∞—Ü–∏—è': 'üí™',
      '–ú—É–¥—Ä–æ—Å—Ç—å': 'üß†',
      '–¢–≤–æ—Ä—á–µ—Å—Ç–≤–æ': 'üé®',
      '–û—Ç–Ω–æ—à–µ–Ω–∏—è': 'üë•',
      '–°—á–∞—Å—Ç—å–µ': 'üòä',
      '–ñ–∏–∑–Ω—å': 'üåü',
      '–£—Å–ø–µ—Ö': 'üèÜ'
    };

    logger.info('üé® ModernQuoteHandler initialized with beautiful UI');
  }

  /**
   * Handle quote submission with beautiful processing
   * @param {Object} ctx - Telegram context
   * @param {string} messageText - Quote text
   * @param {Object} userProfile - User profile
   */
  async handleQuote(ctx, messageText, userProfile) {
    try {
      const userId = ctx.from.id.toString();
      
      // Show processing indicator
      await ctx.sendChatAction('typing');
      
      // Set processing state
      this.processingStates.set(userId, {
        startTime: Date.now(),
        step: 'analyzing'
      });

      // Validate quote
      const validation = await this._validateQuote(userId, messageText);
      if (!validation.valid) {
        await this._sendValidationError(ctx, validation);
        this.processingStates.delete(userId);
        return;
      }

      // Parse quote
      const parsedQuote = this._parseQuote(messageText);
      
      // Update processing state
      this.processingStates.set(userId, {
        startTime: Date.now(),
        step: 'ai_analysis'
      });

      // AI analysis
      const analysis = await this._analyzeQuote(parsedQuote, userProfile);
      
      // Save quote
      const savedQuote = await this._saveQuote(userId, parsedQuote, analysis);
      
      // Update user statistics
      await this._updateUserStatistics(userId, parsedQuote.author);
      
      // Check for achievements
      const achievements = await this._checkAchievements(userId);
      
      // Generate beautiful response
      const response = await this._generateBeautifulResponse(
        parsedQuote, 
        analysis, 
        userProfile, 
        achievements
      );

      // Send response
      await this._sendQuoteConfirmation(ctx, response, savedQuote, achievements);
      
      // Clean up processing state
      this.processingStates.delete(userId);
      
      logger.info(`üìñ Quote processed successfully for user ${userId}`);
      
    } catch (error) {
      logger.error(`üé® Error handling quote: ${error.message}`);
      this.processingStates.delete(ctx.from.id.toString());
      await this._sendErrorMessage(ctx, error);
    }
  }

  /**
   * Validate quote submission
   * @private
   * @param {string} userId - User ID
   * @param {string} messageText - Quote text
   * @returns {Promise<Object>} - Validation result
   */
  async _validateQuote(userId, messageText) {
    try {
      // Check daily limit
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      const todayQuotesCount = await Quote.countDocuments({
        userId,
        createdAt: { $gte: today }
      });

      if (todayQuotesCount >= this.maxQuotesPerDay) {
        return {
          valid: false,
          error: 'daily_limit',
          message: `üìñ –í—ã —É–∂–µ –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ ${this.maxQuotesPerDay} —Ü–∏—Ç–∞—Ç —Å–µ–≥–æ–¥–Ω—è. –í–æ–∑–≤—Ä–∞—â–∞–π—Ç–µ—Å—å –∑–∞–≤—Ç—Ä–∞ –∑–∞ –Ω–æ–≤—ã–º–∏ –æ—Ç–∫—Ä—ã—Ç–∏—è–º–∏!`,
          todayCount: todayQuotesCount
        };
      }

      // Check quote length
      if (messageText.length > this.maxQuoteLength) {
        return {
          valid: false,
          error: 'too_long',
          message: `üìñ –¶–∏—Ç–∞—Ç–∞ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–∞—è (${messageText.length} —Å–∏–º–≤–æ–ª–æ–≤). –ú–∞–∫—Å–∏–º—É–º ${this.maxQuoteLength} —Å–∏–º–≤–æ–ª–æ–≤.`,
          length: messageText.length
        };
      }

      // Check minimum length
      if (messageText.trim().length < 10) {
        return {
          valid: false,
          error: 'too_short',
          message: 'üìñ –¶–∏—Ç–∞—Ç–∞ —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∞—è. –ú–∏–Ω–∏–º—É–º 10 —Å–∏–º–≤–æ–ª–æ–≤ –¥–ª—è –æ—Å–º—ã—Å–ª–µ–Ω–Ω–æ–π –º—ã—Å–ª–∏.',
          length: messageText.trim().length
        };
      }

      return {
        valid: true,
        todayCount: todayQuotesCount
      };

    } catch (error) {
      logger.error(`üé® Error validating quote: ${error.message}`);
      return {
        valid: false,
        error: 'validation_error',
        message: 'üìñ –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Ü–∏—Ç–∞—Ç—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.'
      };
    }
  }

  /**
   * Parse quote text to extract author and content
   * @private
   * @param {string} messageText - Raw message text
   * @returns {Object} - Parsed quote
   */
  _parseQuote(messageText) {
    const text = messageText.trim();
    
    // Patterns to match: "Quote" (Author), Quote (Author), Quote - Author, etc.
    const patterns = [
      /^["¬´]([^"¬´¬ª]+)["¬ª]\s*\(\s*([^)]+)\s*\)$/,  // "Quote" (Author)
      /^([^(]+)\s*\(\s*([^)]+)\s*\)$/,             // Quote (Author)
      /^([^‚Äî‚Äì-]+)\s*[‚Äî‚Äì-]\s*(.+)$/,               // Quote ‚Äî Author
      /^(.+)$/                                     // Just text
    ];

    for (const pattern of patterns) {
      const match = text.match(pattern);
      if (match) {
        if (match[2]) {
          // Has author
          return {
            text: match[1].trim().replace(/^["¬´]|["¬ª]$/g, ''),
            author: match[2].trim(),
            source: null,
            hasAuthor: true
          };
        } else {
          // No author
          return {
            text: match[1].trim().replace(/^["¬´]|["¬ª]$/g, ''),
            author: null,
            source: null,
            hasAuthor: false
          };
        }
      }
    }

    // Fallback
    return {
      text: text.replace(/^["¬´]|["¬ª]$/g, ''),
      author: null,
      source: null,
      hasAuthor: false
    };
  }

  /**
   * Analyze quote with AI
   * @private
   * @param {Object} quote - Parsed quote
   * @param {Object} userProfile - User profile
   * @returns {Promise<Object>} - Analysis results
   */
  async _analyzeQuote(quote, userProfile) {
    try {
      const prompt = `–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —ç—Ç—É —Ü–∏—Ç–∞—Ç—É –∫–∞–∫ –ø—Å–∏—Ö–æ–ª–æ–≥ –ê–Ω–Ω–∞ –ë—É—Å–µ–ª –¥–ª—è –ø—Ä–æ–µ–∫—Ç–∞ "–ß–∏—Ç–∞—Ç–µ–ª—å":

–¶–∏—Ç–∞—Ç–∞: "${quote.text}"
–ê–≤—Ç–æ—Ä: ${quote.author || '–ù–µ–∏–∑–≤–µ—Å—Ç–µ–Ω'}

–ö–æ–Ω—Ç–µ–∫—Å—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:
- –ò–º—è: ${userProfile.name}
- –ò–Ω—Ç–µ—Ä–µ—Å—ã: ${userProfile.preferences?.mainThemes?.join(', ') || '—Ä–∞–∑–≤–∏—Ç–∏–µ'}
- –¢–∏–ø –ª–∏—á–Ω–æ—Å—Ç–∏: ${userProfile.preferences?.personalityType || '–∏—â—É—â–∏–π'}

–í–µ—Ä–Ω–∏ JSON –∞–Ω–∞–ª–∏–∑:
{
  "category": "–æ–¥–Ω–∞ –∏–∑: –°–∞–º–æ—Ä–∞–∑–≤–∏—Ç–∏–µ, –õ—é–±–æ–≤—å, –§–∏–ª–æ—Å–æ—Ñ–∏—è, –ú–æ—Ç–∏–≤–∞—Ü–∏—è, –ú—É–¥—Ä–æ—Å—Ç—å, –¢–≤–æ—Ä—á–µ—Å—Ç–≤–æ, –û—Ç–Ω–æ—à–µ–Ω–∏—è, –°—á–∞—Å—Ç—å–µ, –ñ–∏–∑–Ω—å, –£—Å–ø–µ—Ö",
  "themes": ["—Ç–µ–º–∞1", "—Ç–µ–º–∞2"],
  "sentiment": "positive/neutral/negative",
  "personalRelevance": "–ø–æ—á–µ–º—É —ç—Ç–∞ —Ü–∏—Ç–∞—Ç–∞ –≤–∞–∂–Ω–∞ –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
  "insights": "–∫—Ä–∞—Ç–∫–∏–π –ø—Å–∏—Ö–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π –∏–Ω—Å–∞–π—Ç –æ—Ç –ê–Ω–Ω—ã",
  "bookRecommendation": "–Ω–∞–∑–≤–∞–Ω–∏–µ –∫–Ω–∏–≥–∏ –∫–æ—Ç–æ—Ä–∞—è –ø–æ–¥—Ö–æ–¥–∏—Ç –∫ —Ç–µ–º–µ —Ü–∏—Ç–∞—Ç—ã, –∏–ª–∏ null"
}`;

      const response = await claudeService.generateResponse(prompt, {
        platform: 'telegram',
        userId: 'quote_analysis'
      });
      
      return JSON.parse(response.message);
      
    } catch (error) {
      logger.error(`üé® Error analyzing quote: ${error.message}`);
      
      // Fallback analysis
      return {
        category: '–ú—É–¥—Ä–æ—Å—Ç—å',
        themes: ['—Ä–∞–∑–º—ã—à–ª–µ–Ω–∏—è'],
        sentiment: 'positive',
        personalRelevance: '–≠—Ç–∞ –º—ã—Å–ª—å –≤–∞–∂–Ω–∞ –¥–ª—è –≤–∞—à–µ–≥–æ –ª–∏—á–Ω–æ—Å—Ç–Ω–æ–≥–æ —Ä–∞–∑–≤–∏—Ç–∏—è',
        insights: '–ì–ª—É–±–æ–∫–∞—è –º—ã—Å–ª—å –¥–ª—è —Ä–∞–∑–º—ã—à–ª–µ–Ω–∏—è',
        bookRecommendation: null
      };
    }
  }

  /**
   * Save quote to database
   * @private
   * @param {string} userId - User ID
   * @param {Object} parsedQuote - Parsed quote
   * @param {Object} analysis - AI analysis
   * @returns {Promise<Object>} - Saved quote
   */
  async _saveQuote(userId, parsedQuote, analysis) {
    try {
      const quote = new Quote({
        userId,
        text: parsedQuote.text,
        author: parsedQuote.author,
        source: parsedQuote.source,
        category: analysis.category,
        themes: analysis.themes,
        sentiment: analysis.sentiment,
        weekNumber: this._getWeekNumber(),
        monthNumber: new Date().getMonth() + 1,
        yearNumber: new Date().getFullYear(),
        metadata: {
          personalRelevance: analysis.personalRelevance,
          insights: analysis.insights,
          bookRecommendation: analysis.bookRecommendation
        }
      });

      return await quote.save();
      
    } catch (error) {
      logger.error(`üé® Error saving quote: ${error.message}`);
      throw new Error('Failed to save quote');
    }
  }

  /**
   * Update user statistics
   * @private
   * @param {string} userId - User ID
   * @param {string} author - Quote author
   */
  async _updateUserStatistics(userId, author) {
    try {
      const userProfile = await UserProfile.findOne({ userId });
      if (!userProfile) return;

      // Update total quotes count
      userProfile.statistics.totalQuotes += 1;

      // Update favorite authors
      if (author && author.trim()) {
        const authorName = author.trim();
        if (!userProfile.statistics.favoriteAuthors.includes(authorName)) {
          userProfile.statistics.favoriteAuthors.push(authorName);
          
          // Keep only last 20 authors
          if (userProfile.statistics.favoriteAuthors.length > 20) {
            userProfile.statistics.favoriteAuthors = 
              userProfile.statistics.favoriteAuthors.slice(-20);
          }
        }
      }

      // Update streak
      await this._updateStreak(userId, userProfile);

      // Update monthly stats
      const currentMonth = new Date().getMonth() + 1;
      const currentYear = new Date().getFullYear();
      
      const monthlyRecord = userProfile.statistics.monthlyQuotes.find(
        m => m.month === currentMonth && m.year === currentYear
      );
      
      if (monthlyRecord) {
        monthlyRecord.count += 1;
      } else {
        userProfile.statistics.monthlyQuotes.push({
          month: currentMonth,
          year: currentYear,
          count: 1
        });
      }

      await userProfile.save();
      
    } catch (error) {
      logger.error(`üé® Error updating user statistics: ${error.message}`);
    }
  }

  /**
   * Update user streak
   * @private
   * @param {string} userId - User ID
   * @param {Object} userProfile - User profile
   */
  async _updateStreak(userId, userProfile) {
    try {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      const yesterday = new Date(today);
      yesterday.setDate(yesterday.getDate() - 1);

      // Check if user had quotes yesterday
      const yesterdayQuotes = await Quote.countDocuments({
        userId,
        createdAt: { $gte: yesterday, $lt: today }
      });

      // Check if user had quotes today (before this one)
      const todayQuotesBefore = await Quote.countDocuments({
        userId,
        createdAt: { $gte: today }
      });

      if (todayQuotesBefore === 1) {
        // First quote today
        if (yesterdayQuotes > 0) {
          // Continue streak
          userProfile.statistics.currentStreak += 1;
        } else {
          // Start new streak
          userProfile.statistics.currentStreak = 1;
        }

        // Update longest streak
        if (userProfile.statistics.currentStreak > userProfile.statistics.longestStreak) {
          userProfile.statistics.longestStreak = userProfile.statistics.currentStreak;
        }
      }
      
    } catch (error) {
      logger.error(`üé® Error updating streak: ${error.message}`);
    }
  }

  /**
   * Check for new achievements
   * @private
   * @param {string} userId - User ID
   * @returns {Promise<Array>} - New achievements
   */
  async _checkAchievements(userId) {
    try {
      const userProfile = await UserProfile.findOne({ userId });
      const newAchievements = [];

      const achievements = [
        {
          id: 'first_quote',
          name: '–ü–µ—Ä–≤—ã–µ —à–∞–≥–∏',
          description: '–°–æ—Ö—Ä–∞–Ω–∏–ª–∏ –ø–µ—Ä–≤—É—é —Ü–∏—Ç–∞—Ç—É',
          icon: 'üå±',
          requirement: 'quotes_count',
          target: 1
        },
        {
          id: 'wisdom_collector',
          name: '–ö–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä –º—É–¥—Ä–æ—Å—Ç–∏',
          description: '–°–æ–±—Ä–∞–ª–∏ 25 —Ü–∏—Ç–∞—Ç',
          icon: 'üìö',
          requirement: 'quotes_count',
          target: 25
        },
        {
          id: 'week_philosopher',
          name: '–§–∏–ª–æ—Å–æ—Ñ –Ω–µ–¥–µ–ª–∏',
          description: '7 –¥–Ω–µ–π –ø–æ–¥—Ä—è–¥ —Å —Ü–∏—Ç–∞—Ç–∞–º–∏',
          icon: 'üî•',
          requirement: 'streak_days',
          target: 7
        },
        {
          id: 'month_scholar',
          name: '–£—á–µ–Ω—ã–π –º–µ—Å—è—Ü–∞',
          description: '30 –¥–Ω–µ–π –ø–æ–¥—Ä—è–¥',
          icon: 'üéì',
          requirement: 'streak_days',
          target: 30
        },
        {
          id: 'inspiration_seeker',
          name: '–ò—Å–∫–∞—Ç–µ–ª—å –≤–¥–æ—Ö–Ω–æ–≤–µ–Ω–∏—è',
          description: '100 —Ü–∏—Ç–∞—Ç —Å–æ–±—Ä–∞–Ω–æ',
          icon: '‚≠ê',
          requirement: 'quotes_count',
          target: 100
        }
      ];

      for (const achievement of achievements) {
        // Check if already has this achievement
        if (userProfile.achievements.some(a => a.achievementId === achievement.id)) {
          continue;
        }

        let unlocked = false;

        switch (achievement.requirement) {
          case 'quotes_count':
            unlocked = userProfile.statistics.totalQuotes >= achievement.target;
            break;
          case 'streak_days':
            unlocked = userProfile.statistics.currentStreak >= achievement.target;
            break;
        }

        if (unlocked) {
          userProfile.achievements.push({
            achievementId: achievement.id,
            unlockedAt: new Date()
          });
          newAchievements.push(achievement);
        }
      }

      if (newAchievements.length > 0) {
        await userProfile.save();
      }

      return newAchievements;
      
    } catch (error) {
      logger.error(`üé® Error checking achievements: ${error.message}`);
      return [];
    }
  }

  /**
   * Generate beautiful response
   * @private
   * @param {Object} quote - Parsed quote
   * @param {Object} analysis - AI analysis
   * @param {Object} userProfile - User profile
   * @param {Array} achievements - New achievements
   * @returns {Promise<Object>} - Response data
   */
  async _generateBeautifulResponse(quote, analysis, userProfile, achievements) {
    try {
      // Select appropriate template
      const templateType = quote.hasAuthor ? 'author_quote' : 'no_author_quote';
      const templates = this.responseTemplates.find(t => t.pattern === templateType);
      const randomTemplate = templates.templates[Math.floor(Math.random() * templates.templates.length)];
      
      // Generate base response
      let baseResponse = randomTemplate.replace('{author}', quote.author || '');
      
      // Add category emoji
      const categoryEmoji = this.categoryEmojis[analysis.category] || 'üìñ';
      
      // Get today's stats
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const todayQuotes = await Quote.countDocuments({
        userId: userProfile.userId,
        createdAt: { $gte: today }
      });

      // Build response object
      const response = {
        baseMessage: baseResponse,
        category: analysis.category,
        categoryEmoji,
        todayCount: todayQuotes,
        maxDaily: this.maxQuotesPerDay,
        insights: analysis.insights,
        personalRelevance: analysis.personalRelevance,
        bookRecommendation: analysis.bookRecommendation,
        achievements: achievements,
        totalQuotes: userProfile.statistics.totalQuotes + 1,
        currentStreak: userProfile.statistics.currentStreak
      };

      return response;
      
    } catch (error) {
      logger.error(`üé® Error generating response: ${error.message}`);
      return {
        baseMessage: '‚ú® –¶–∏—Ç–∞—Ç–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ –≤–∞—à –¥–Ω–µ–≤–Ω–∏–∫!',
        category: '–ú—É–¥—Ä–æ—Å—Ç—å',
        categoryEmoji: 'üìñ',
        todayCount: 1,
        maxDaily: this.maxQuotesPerDay,
        insights: '–ü—Ä–µ–∫—Ä–∞—Å–Ω–∞—è –º—ã—Å–ª—å –¥–ª—è —Ä–∞–∑–º—ã—à–ª–µ–Ω–∏—è',
        personalRelevance: '–í–∞–∂–Ω–æ –¥–ª—è —Ä–∞–∑–≤–∏—Ç–∏—è',
        bookRecommendation: null,
        achievements: [],
        totalQuotes: 1,
        currentStreak: 1
      };
    }
  }

  /**
   * Send beautiful quote confirmation
   * @private
   * @param {Object} ctx - Telegram context
   * @param {Object} response - Response data
   * @param {Object} quote - Saved quote
   * @param {Array} achievements - New achievements
   */
  async _sendQuoteConfirmation(ctx, response, quote, achievements) {
    try {
      // Main confirmation message
      let confirmationText = `
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ   ‚úÖ –¶–ò–¢–ê–¢–ê –°–û–•–†–ê–ù–ï–ù–ê   ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

${response.baseMessage}

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       –°–¢–ê–¢–ò–°–¢–ò–ö–ê        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
${response.categoryEmoji} –ö–∞—Ç–µ–≥–æ—Ä–∏—è: ${response.category}
üìä –°–µ–≥–æ–¥–Ω—è: ${response.todayCount}/${response.maxDaily}
üìö –í—Å–µ–≥–æ —Ü–∏—Ç–∞—Ç: ${response.totalQuotes}
üî• –°–µ—Ä–∏—è –¥–Ω–µ–π: ${response.currentStreak}

üí° ${response.insights}`;

      // Add book recommendation if available
      if (response.bookRecommendation) {
        confirmationText += `
        
üìñ –ö—Å—Ç–∞—Ç–∏, –µ—Å–ª–∏ –≤–∞—Å –ø—Ä–∏–≤–ª–µ–∫–∞–µ—Ç —ç—Ç–∞ —Ç–µ–º–∞, 
   —Ä–µ–∫–æ–º–µ–Ω–¥—É—é —Ä–∞–∑–±–æ—Ä "${response.bookRecommendation}" 
   –æ—Ç –ê–Ω–Ω—ã.`;
      }

      // Keyboard with actions
      const keyboard = {
        inline_keyboard: [
          [
            { text: "üìö –ú–æ–π –¥–Ω–µ–≤–Ω–∏–∫", callback_data: "nav_diary" },
            { text: "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data: "nav_stats" }
          ],
          [
            { text: "‚ú® –ï—â–µ —Ü–∏—Ç–∞—Ç—É", callback_data: "nav_add_quote" },
            { text: "üìñ –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data: "nav_main" }
          ]
        ]
      };

      await ctx.reply(confirmationText, { reply_markup: keyboard });

      // Send achievement notifications separately
      if (achievements.length > 0) {
        for (const achievement of achievements) {
          const achievementMessage = `
üéâ *–ü–û–ó–î–†–ê–í–õ–Ø–Æ!*

–í—ã –ø–æ–ª—É—á–∏–ª–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ:

${achievement.icon} *${achievement.name}*
${achievement.description}

–ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ —Å–æ–±–∏—Ä–∞—Ç—å –º–æ–º–µ–Ω—Ç—ã –≤–¥–æ—Ö–Ω–æ–≤–µ–Ω–∏—è! üìñ`;

          await ctx.reply(achievementMessage, { 
            parse_mode: 'Markdown',
            reply_markup: {
              inline_keyboard: [
                [{ text: "üèÜ –í—Å–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è", callback_data: "nav_achievements" }]
              ]
            }
          });
        }
      }
      
    } catch (error) {
      logger.error(`üé® Error sending quote confirmation: ${error.message}`);
      await ctx.reply('‚úÖ –¶–∏—Ç–∞—Ç–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ –≤–∞—à –¥–Ω–µ–≤–Ω–∏–∫!\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /menu –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏.');
    }
  }

  /**
   * Send validation error message
   * @private
   * @param {Object} ctx - Telegram context
   * @param {Object} validation - Validation result
   */
  async _sendValidationError(ctx, validation) {
    try {
      let errorPanel = `
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ     ‚ö†Ô∏è –í–ù–ò–ú–ê–ù–ò–ï        ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

${validation.message}`;

      const keyboard = {
        inline_keyboard: [
          [{ text: "üìñ –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data: "nav_main" }]
        ]
      };

      if (validation.error === 'daily_limit') {
        errorPanel += `

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    –ê –ü–û–ö–ê –ú–û–ñ–ï–¢–ï:       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
üìö –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –¥–Ω–µ–≤–Ω–∏–∫ —Ü–∏—Ç–∞—Ç
üìä –ò–∑—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
üíé –ü–æ—á–∏—Ç–∞—Ç—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ê–Ω–Ω—ã

üí° –ó–∞–≤—Ç—Ä–∞ –≤–∞—Å –∂–¥—É—Ç –Ω–æ–≤—ã–µ 
   –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –¥–ª—è —Å–±–æ—Ä–∞ –º—É–¥—Ä–æ—Å—Ç–∏!`;

        keyboard.inline_keyboard.unshift(
          [
            { text: "üìö –ú–æ–π –¥–Ω–µ–≤–Ω–∏–∫", callback_data: "nav_diary" },
            { text: "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data: "nav_stats" }
          ]
        );
      }

      await ctx.reply(errorPanel, { reply_markup: keyboard });
      
    } catch (error) {
      logger.error(`üé® Error sending validation error: ${error.message}`);
      await ctx.reply(validation.message || 'üìñ –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ü–∏—Ç–∞—Ç—ã.');
    }
  }

  /**
   * Send error message
   * @private
   * @param {Object} ctx - Telegram context
   * @param {Error} error - Error object
   */
  async _sendErrorMessage(ctx, error) {
    try {
      let errorMessage = 'üìñ –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ü–∏—Ç–∞—Ç—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ —á–µ—Ä–µ–∑ –º–∏–Ω—É—Ç—É.';

      if (error.message.includes('validation')) {
        errorMessage = 'üìñ –û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ —Ü–∏—Ç–∞—Ç—ã. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–æ—Ä–º–∞—Ç –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.';
      } else if (error.message.includes('save')) {
        errorMessage = 'üìñ –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ü–∏—Ç–∞—Ç—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.';
      }

      const errorPanel = `
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ      ‚ùå –û–®–ò–ë–ö–ê         ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

${errorMessage}

üí° –ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º–∞ –ø–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è, 
   –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –ê–Ω–Ω–µ —á–µ—Ä–µ–∑ 
   —Ä–∞–∑–¥–µ–ª "–ü–æ–º–æ—â—å".`;

      await ctx.reply(errorPanel, {
        reply_markup: {
          inline_keyboard: [
            [{ text: "üîÑ –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞", callback_data: "nav_add_quote" }],
            [{ text: "üí¨ –°–≤—è–∑–∞—Ç—å—Å—è —Å –ê–Ω–Ω–æ–π", callback_data: "nav_contact" }],
            [{ text: "üìñ –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data: "nav_main" }]
          ]
        }
      });
      
    } catch (sendError) {
      logger.error(`üé® Failed to send error message: ${sendError.message}`);
      await ctx.reply('üìñ –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ /start');
    }
  }

  /**
   * Get current week number
   * @private
   * @returns {number} - ISO week number
   */
  _getWeekNumber() {
    const date = new Date();
    const onejan = new Date(date.getFullYear(), 0, 1);
    const millisecsInDay = 86400000;
    return Math.ceil((((date - onejan) / millisecsInDay) + onejan.getDay() + 1) / 7);
  }

  /**
   * Get quote handler statistics
   * @returns {Object} - Quote handler stats
   */
  getStats() {
    return {
      processingStates: this.processingStates.size,
      maxQuotesPerDay: this.maxQuotesPerDay,
      maxQuoteLength: this.maxQuoteLength,
      templateCount: this.responseTemplates.length,
      categoryCount: Object.keys(this.categoryEmojis).length
    };
  }

  /**
   * Cleanup resources
   */
  cleanup() {
    this.processingStates.clear();
    logger.info('üé® ModernQuoteHandler cleanup completed');
  }
}

module.exports = { ModernQuoteHandler };