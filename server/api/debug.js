/**
 * üîç DEBUG API –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ –ø—Ä–æ–±–ª–µ–º Telegram Mini App
 * 
 * –°–æ–±–∏—Ä–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –æ viewport –ø—Ä–æ–±–ª–µ–º–∞—Ö, –ª–æ–≥–∏—Ä—É–µ—Ç –∏—Ö –≤ –ë–î
 * –∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –∞–Ω–∞–ª–∏—Ç–∏–∫—É –¥–ª—è –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–∞–≥–æ–≤
 * 
 * @filesize ~8KB
 * @version 1.0.1
 */

const express = require('express');
const router = express.Router();
const ViewportLog = require('../models/ViewportLog');
const logger = require('../utils/logger');

/**
 * @typedef {import('../types').ShroomsError} ShroomsError
 */

/**
 * üì± POST /api/debug/viewport - –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ viewport –ø—Ä–æ–±–ª–µ–º
 * 
 * –ü—Ä–∏–Ω–∏–º–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –æ viewport —Å –∫–ª–∏–µ–Ω—Ç–∞ –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –≤ –ë–î –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
 * –ü–æ–º–æ–≥–∞–µ—Ç –¥–∏–∞–≥–Ω–æ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–±–ª–µ–º—ã —Å –ø—É—Å—Ç—ã–º –º–µ—Å—Ç–æ–º —Å–Ω–∏–∑—É –≤ Mini App
 */
router.post('/viewport', async (req, res) => {
  try {
    const {
      sessionId,
      page,
      url,
      viewport,
      device,
      telegram,
      problem,
      debugMode = false,
      cssVariables,
      notes
    } = req.body;

    // üîç –í–∞–ª–∏–¥–∞—Ü–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π
    if (!sessionId || !page || !viewport || !device || !problem) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields',
        required: ['sessionId', 'page', 'viewport', 'device', 'problem']
      });
    }

    // üìä –õ–æ–≥–∏—Ä—É–µ–º –ø–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
    logger.info('üîç [DEBUG] Viewport issue reported:', {
      sessionId: sessionId.substring(0, 8),
      page,
      platform: device.platform,
      problemType: problem.type,
      difference: viewport.difference,
      userAgent: device.userAgent.substring(0, 50) + '...'
    });

    // üõ†Ô∏è –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—Ä–æ–±–ª–µ–º—É –∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø
    const problemType = determineProblemType(viewport, problem);
    const severity = determineSeverity(viewport.difference);

    // üîß –ò–°–ü–†–ê–í–õ–ï–ù–û: –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –ø–µ—Ä–µ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º
    const bottomNavHeight = viewport.bottomNavHeight || 64;
    const headerHeight = viewport.headerHeight || 56;
    const totalSubtracted = bottomNavHeight + headerHeight + 40; // padding
    const availableHeight = viewport.innerHeight - totalSubtracted;

    // üíæ –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –≤ –ë–î
    const viewportLog = new ViewportLog({
      sessionId,
      page,
      url: url || `/mini-app/${page}`,
      viewport: {
        innerHeight: viewport.innerHeight,
        innerWidth: viewport.innerWidth,
        telegramHeight: viewport.telegramHeight,
        telegramStableHeight: viewport.telegramStableHeight,
        telegramExpanded: viewport.telegramExpanded,
        calculatedContentHeight: viewport.calculatedContentHeight,
        actualContentHeight: viewport.actualContentHeight,
        bottomNavHeight: bottomNavHeight,
        headerHeight: headerHeight,
        // üîß –ò–°–ü–†–ê–í–õ–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è
        totalSubtracted: totalSubtracted,
        availableHeight: availableHeight,
        difference: viewport.difference,
        safeBounds: viewport.safeBounds || { top: 0, bottom: 0, left: 0, right: 0 }
      },
      device: {
        userAgent: device.userAgent,
        platform: device.platform || detectPlatform(device.userAgent),
        browser: device.browser || detectBrowser(device.userAgent),
        devicePixelRatio: device.devicePixelRatio || 1,
        orientation: device.orientation || 'portrait',
        screen: device.screen
      },
      telegram: {
        isAvailable: telegram?.isAvailable || false,
        version: telegram?.version,
        platform: telegram?.platform,
        colorScheme: telegram?.colorScheme,
        isVerticalSwipesEnabled: telegram?.isVerticalSwipesEnabled,
        headerColor: telegram?.headerColor,
        backgroundColor: telegram?.backgroundColor
      },
      problem: {
        type: problemType,
        severity: severity,
        description: problem.description || generateProblemDescription(viewport, problemType),
        scrollTop: problem.scrollTop || 0,
        scrollHeight: problem.scrollHeight || 0,
        clientHeight: problem.clientHeight || 0
      },
      debugMode,
      cssVariables: cssVariables || {},
      notes
    });

    // üíæ –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î
    await viewportLog.save();

    // üìä –õ–æ–≥–∏—Ä—É–µ–º —É—Å–ø–µ—à–Ω–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
    logger.info('‚úÖ [DEBUG] Viewport log saved:', {
      id: viewportLog._id,
      sessionId: sessionId.substring(0, 8),
      problemType,
      severity,
      difference: viewport.difference
    });

    // üö® –ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º–∞ —Å–µ—Ä—å–µ–∑–Ω–∞—è - –ª–æ–≥–∏—Ä—É–µ–º —Å –ø–æ–≤—ã—à–µ–Ω–Ω—ã–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º
    if (severity === 'severe') {
      logger.warn('üö® [DEBUG] SEVERE viewport issue detected:', {
        platform: device.platform,
        page,
        difference: viewport.difference,
        userAgent: device.userAgent
      });
    }

    // ‚úÖ –í–æ–∑–≤—Ä–∞—â–∞–µ–º —É—Å–ø–µ—à–Ω—ã–π –æ—Ç–≤–µ—Ç
    res.json({
      success: true,
      message: 'Viewport data logged successfully',
      logId: viewportLog._id,
      analysis: {
        problemType,
        severity,
        recommendation: getRecommendation(problemType, viewport)
      }
    });

  } catch (error) {
    logger.error('‚ùå [DEBUG] Failed to log viewport data:', {
      error: error.message,
      stack: error.stack,
      body: req.body
    });

    res.status(500).json({
      success: false,
      error: 'Failed to log viewport data',
      details: error.message
    });
  }
});

/**
 * üìä GET /api/debug/viewport/stats - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ viewport –ø—Ä–æ–±–ª–µ–º
 * 
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∞–Ω–∞–ª–∏—Ç–∏–∫—É –ø–æ —Å–æ–±—Ä–∞–Ω–Ω—ã–º –¥–∞–Ω–Ω—ã–º viewport
 */
router.get('/viewport/stats', async (req, res) => {
  try {
    const { platform, page, limit = 100, days = 7 } = req.query;

    // üìÖ –§–∏–ª—å—Ç—Ä –ø–æ –¥–∞—Ç–µ
    const dateFilter = {
      timestamp: {
        $gte: new Date(Date.now() - days * 24 * 60 * 60 * 1000)
      }
    };

    // üîç –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
    const filters = { ...dateFilter };
    if (platform) filters['device.platform'] = platform;
    if (page) filters.page = page;

    // üìä –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
    const [
      totalLogs,
      problemsByType,
      problemsByPlatform,
      problemsByPage,
      recentProblems,
      averageMetrics
    ] = await Promise.all([
      ViewportLog.countDocuments(filters),
      
      ViewportLog.aggregate([
        { $match: filters },
        { $group: { _id: '$problem.type', count: { $sum: 1 } } },
        { $sort: { count: -1 } }
      ]),
      
      ViewportLog.aggregate([
        { $match: filters },
        { $group: { _id: '$device.platform', count: { $sum: 1 } } },
        { $sort: { count: -1 } }
      ]),
      
      ViewportLog.aggregate([
        { $match: filters },
        { $group: { _id: '$page', count: { $sum: 1 } } },
        { $sort: { count: -1 } }
      ]),
      
      ViewportLog.find(filters)
        .sort({ timestamp: -1 })
        .limit(parseInt(limit))
        .select('page device.platform problem.type viewport.difference timestamp')
        .lean(),
        
      ViewportLog.aggregate([
        { $match: filters },
        {
          $group: {
            _id: null,
            avgDifference: { $avg: '$viewport.difference' },
            avgInnerHeight: { $avg: '$viewport.innerHeight' },
            avgTelegramHeight: { $avg: '$viewport.telegramHeight' },
            avgBottomNavHeight: { $avg: '$viewport.bottomNavHeight' },
            avgHeaderHeight: { $avg: '$viewport.headerHeight' }
          }
        }
      ])
    ]);

    // üìà –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
    const stats = {
      summary: {
        totalLogs,
        period: `${days} days`,
        platforms: problemsByPlatform.length,
        pages: problemsByPage.length
      },
      problems: {
        byType: problemsByType,
        byPlatform: problemsByPlatform,
        byPage: problemsByPage
      },
      metrics: averageMetrics[0] || {},
      recent: recentProblems
    };

    logger.info('üìä [DEBUG] Stats requested:', {
      platform,
      page,
      totalLogs,
      days
    });

    res.json({
      success: true,
      data: stats
    });

  } catch (error) {
    logger.error('‚ùå [DEBUG] Failed to get viewport stats:', error);
    
    res.status(500).json({
      success: false,
      error: 'Failed to get viewport statistics',
      details: error.message
    });
  }
});

/**
 * üîç GET /api/debug/viewport/analysis - –î–µ—Ç–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –ø—Ä–æ–±–ª–µ–º
 * 
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–µ—Ç–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –ø—Ä–æ–±–ª–µ–º—ã –∏–ª–∏ —Ç–∏–ø–∞ –ø—Ä–æ–±–ª–µ–º
 */
router.get('/viewport/analysis', async (req, res) => {
  try {
    const { logId, problemType, platform } = req.query;

    let analysisData;

    if (logId) {
      // –ê–Ω–∞–ª–∏–∑ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –∑–∞–ø–∏—Å–∏
      analysisData = await ViewportLog.findById(logId).lean();
      if (!analysisData) {
        return res.status(404).json({
          success: false,
          error: 'Viewport log not found'
        });
      }
    } else {
      // –ê–Ω–∞–ª–∏–∑ –ø–æ —Ç–∏–ø—É –ø—Ä–æ–±–ª–µ–º—ã –∏–ª–∏ –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ
      const filters = {};
      if (problemType) filters['problem.type'] = problemType;
      if (platform) filters['device.platform'] = platform;

      analysisData = await ViewportLog.aggregate([
        { $match: filters },
        {
          $group: {
            _id: {
              platform: '$device.platform',
              page: '$page',
              problemType: '$problem.type'
            },
            count: { $sum: 1 },
            avgDifference: { $avg: '$viewport.difference' },
            minDifference: { $min: '$viewport.difference' },
            maxDifference: { $max: '$viewport.difference' },
            avgInnerHeight: { $avg: '$viewport.innerHeight' },
            avgTelegramHeight: { $avg: '$viewport.telegramHeight' },
            samples: { $push: '$$ROOT' }
          }
        },
        { $sort: { count: -1 } },
        { $limit: 20 }
      ]);
    }

    res.json({
      success: true,
      data: analysisData,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    logger.error('‚ùå [DEBUG] Failed to get viewport analysis:', error);
    
    res.status(500).json({
      success: false,
      error: 'Failed to get viewport analysis',
      details: error.message
    });
  }
});

/**
 * üóëÔ∏è DELETE /api/debug/viewport/clear - –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –ª–æ–≥–æ–≤
 * 
 * –£–¥–∞–ª—è–µ—Ç —Å—Ç–∞—Ä—ã–µ –∑–∞–ø–∏—Å–∏ viewport –ª–æ–≥–æ–≤ –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –º–µ—Å—Ç–∞
 */
router.delete('/viewport/clear', async (req, res) => {
  try {
    const { days = 30 } = req.query;
    
    const cutoffDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
    
    const result = await ViewportLog.deleteMany({
      timestamp: { $lt: cutoffDate }
    });

    logger.info('üóëÔ∏è [DEBUG] Viewport logs cleaned:', {
      deletedCount: result.deletedCount,
      cutoffDate,
      days
    });

    res.json({
      success: true,
      message: `Deleted ${result.deletedCount} old viewport logs`,
      deletedCount: result.deletedCount,
      cutoffDate
    });

  } catch (error) {
    logger.error('‚ùå [DEBUG] Failed to clear viewport logs:', error);
    
    res.status(500).json({
      success: false,
      error: 'Failed to clear viewport logs',
      details: error.message
    });
  }
});

// ===========================================
// üõ†Ô∏è –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò
// ===========================================

/**
 * –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–∏–ø –ø—Ä–æ–±–ª–µ–º—ã viewport
 */
function determineProblemType(viewport, problem) {
  const diff = viewport.difference;
  
  if (problem.type) return problem.type;
  
  if (diff > 10) return 'empty_space_bottom';
  if (diff < -10) return 'content_overflow';
  if (Math.abs(diff) < 10) return 'height_mismatch';
  
  return 'scroll_issue';
}

/**
 * –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å–µ—Ä—å–µ–∑–Ω–æ—Å—Ç—å –ø—Ä–æ–±–ª–µ–º—ã
 */
function determineSeverity(difference) {
  const abs = Math.abs(difference);
  
  if (abs < 10) return 'minor';
  if (abs < 50) return 'moderate';
  return 'severe';
}

/**
 * –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–ª–∞—Ç—Ñ–æ—Ä–º—É –ø–æ User Agent
 */
function detectPlatform(userAgent) {
  if (/iPhone|iPad|iPod/i.test(userAgent)) return 'iOS';
  if (/Android/i.test(userAgent)) return 'Android';
  if (/Windows|Mac|Linux/i.test(userAgent)) return 'Desktop';
  return 'Unknown';
}

/**
 * –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –±—Ä–∞—É–∑–µ—Ä –ø–æ User Agent
 */
function detectBrowser(userAgent) {
  if (/TelegramWebApp/i.test(userAgent)) return 'Telegram';
  if (/Chrome/i.test(userAgent)) return 'Chrome';
  if (/Safari/i.test(userAgent)) return 'Safari';
  if (/Firefox/i.test(userAgent)) return 'Firefox';
  return 'Unknown';
}

/**
 * –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º—ã
 */
function generateProblemDescription(viewport, problemType) {
  const diff = viewport.difference;
  
  switch (problemType) {
    case 'empty_space_bottom':
      return `Empty space at bottom: ${diff}px gap between content and navigation`;
    case 'content_overflow':
      return `Content overflow: ${Math.abs(diff)}px content hidden below viewport`;
    case 'height_mismatch':
      return `Height calculation mismatch: ${diff}px difference in expected vs actual`;
    case 'scroll_issue':
      return `Scroll behavior issue with ${diff}px viewport difference`;
    default:
      return `Viewport issue: ${diff}px difference detected`;
  }
}

/**
 * –ü–æ–ª—É—á–∏—Ç—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—é –ø–æ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—é
 */
function getRecommendation(problemType, viewport) {
  switch (problemType) {
    case 'empty_space_bottom':
      return 'Consider reducing bottom padding or adjusting content height calculation';
    case 'content_overflow':
      return 'Increase content container height or enable scrolling';
    case 'height_mismatch':
      return 'Review CSS calc() formulas and Telegram viewport integration';
    case 'scroll_issue':
      return 'Check scroll container configuration and overflow settings';
    default:
      return 'Review viewport height calculation logic';
  }
}

module.exports = router;