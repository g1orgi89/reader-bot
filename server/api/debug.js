/**
 * ðŸ” DEBUG API Ð´Ð»Ñ Ð´Ð¸Ð°Ð³Ð½Ð¾ÑÑ‚Ð¸ÐºÐ¸ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼ Telegram Mini App
 * 
 * Ð¡Ð¾Ð±Ð¸Ñ€Ð°ÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¾ viewport Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ð°Ñ…, Ð»Ð¾Ð³Ð¸Ñ€ÑƒÐµÑ‚ Ð¸Ñ… Ð² Ð‘Ð”
 * Ð¸ Ð¿Ñ€ÐµÐ´Ð¾ÑÑ‚Ð°Ð²Ð»ÑÐµÑ‚ Ð°Ð½Ð°Ð»Ð¸Ñ‚Ð¸ÐºÑƒ Ð´Ð»Ñ Ð¸ÑÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ð±Ð°Ð³Ð¾Ð²
 * 
 * ðŸ”§ ÐžÐ‘ÐÐžÐ’Ð›Ð•ÐÐž: ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ° Ñ€Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð½Ð¾Ð¹ Ð´Ð¸Ð°Ð³Ð½Ð¾ÑÑ‚Ð¸ÐºÐ¸ v2.0
 * 
 * @filesize ~10KB
 * @version 2.0.0
 */

const express = require('express');
const router = express.Router();
const ViewportLog = require('../models/ViewportLog');
const logger = require('../utils/logger');

/**
 * @typedef {import('../types').ShroomsError} ShroomsError
 */

/**
 * ðŸ“± POST /api/debug/viewport - Ð›Ð¾Ð³Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ viewport Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼
 * 
 * ðŸ”§ ÐžÐ‘ÐÐžÐ’Ð›Ð•ÐÐž: ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ° Ñ€Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð½Ñ‹Ñ… Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð´Ð¸Ð°Ð³Ð½Ð¾ÑÑ‚Ð¸ÐºÐ¸ v2.0
 * ÐŸÑ€Ð¸Ð½Ð¸Ð¼Ð°ÐµÑ‚ Ð´ÐµÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¾ viewport Ñ ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð° Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½ÑÐµÑ‚ Ð² Ð‘Ð” Ð´Ð»Ñ Ð°Ð½Ð°Ð»Ð¸Ð·Ð°
 */
router.post('/viewport', async (req, res) => {
  try {\n    // ðŸ”§ ÐÐžÐ’ÐžÐ•: ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ° Ñ€Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð½Ð¾Ð¹ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ñ…
    const {\n      sessionId,\n      page,\n      url,\n      viewport,\n      device,\n      telegram,\n      problem,\n      debugMode = false,\n      cssVariables,\n      notes,\n      // ðŸ†• ÐÐžÐ’Ð«Ð• ÐŸÐžÐ›Ð¯ Ð ÐÐ¡Ð¨Ð˜Ð Ð•ÐÐÐžÐ™ Ð”Ð˜ÐÐ“ÐÐžÐ¡Ð¢Ð˜ÐšÐ˜\n      sizes,\n      fixedElements,\n      document: documentMetrics,\n      content,\n      ios,\n      timestamp\n    } = req.body;\n\n    // ðŸ” Ð’Ð°Ð»Ð¸Ð´Ð°Ñ†Ð¸Ñ Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ñ… Ð¿Ð¾Ð»ÐµÐ¹\n    if (!sessionId || !page || !viewport || !device || !problem) {\n      return res.status(400).json({\n        success: false,\n        error: 'Missing required fields',\n        required: ['sessionId', 'page', 'viewport', 'device', 'problem']\n      });\n    }\n\n    // ðŸ”§ ÐÐžÐ’ÐžÐ•: Ð”ÐµÑ‚Ð°Ð»ÑŒÐ½Ð¾Ðµ Ð»Ð¾Ð³Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ Ñ€Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð½Ñ‹Ñ… Ð´Ð°Ð½Ð½Ñ‹Ñ…\n    const logData = {\n      sessionId: sessionId.substring(0, 8),\n      page,\n      platform: device.platform,\n      problemType: problem.type,\n      difference: viewport.difference,\n      userAgent: device.userAgent.substring(0, 50) + '...'\n    };\n\n    // ðŸ”§ ÐÐžÐ’ÐžÐ•: Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ Ð¾ Ñ€Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð½Ð¾Ð¹ Ð´Ð¸Ð°Ð³Ð½Ð¾ÑÑ‚Ð¸ÐºÐµ\n    if (sizes) {\n      logData.realSizes = {\n        header: sizes.real?.headerHeight,\n        nav: sizes.real?.bottomNavHeight\n      };\n      logData.cssSizes = {\n        header: sizes.css?.headerHeight,\n        nav: sizes.css?.bottomNavHeight\n      };\n      logData.sizeDifferences = sizes.comparison;\n    }\n\n    if (fixedElements?.length) {\n      logData.fixedElementsCount = fixedElements.length;\n    }\n\n    if (ios?.isIOS) {\n      logData.iosMetrics = {\n        isIOS: ios.isIOS,\n        safeAreaSupport: ios.safeAreaSupport,\n        visualViewportHeight: ios.visualViewport?.height\n      };\n    }\n\n    // ðŸ“Š Ð›Ð¾Ð³Ð¸Ñ€ÑƒÐµÐ¼ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ…\n    logger.info('ðŸ” [DEBUG] Viewport issue reported v2.0:', logData);\n\n    // ðŸ› ï¸ ÐÐ½Ð°Ð»Ð¸Ð·Ð¸Ñ€ÑƒÐµÐ¼ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñƒ Ð¸ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÐ¼ Ñ‚Ð¸Ð¿\n    const problemType = determineProblemType(viewport, problem);\n    const severity = determineSeverity(viewport.difference);\n\n    // ðŸ”§ Ð˜Ð¡ÐŸÐ ÐÐ’Ð›Ð•ÐÐž: Ð Ð°ÑÑÑ‡Ð¸Ñ‚Ñ‹Ð²Ð°ÐµÐ¼ Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ð¿Ð¾Ð»Ñ Ð¿ÐµÑ€ÐµÐ´ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸ÐµÐ¼\n    const bottomNavHeight = viewport.bottomNavHeight || sizes?.css?.bottomNavHeight || sizes?.real?.bottomNavHeight || 64;\n    const headerHeight = viewport.headerHeight || sizes?.css?.headerHeight || sizes?.real?.headerHeight || 56;\n    const totalSubtracted = bottomNavHeight + headerHeight + 40; // padding\n    const availableHeight = viewport.innerHeight - totalSubtracted;\n\n    // ðŸ’¾ Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ð·Ð°Ð¿Ð¸ÑÑŒ Ð² Ð‘Ð” Ñ Ñ€Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð½Ñ‹Ð¼Ð¸ Ð´Ð°Ð½Ð½Ñ‹Ð¼Ð¸\n    const viewportLogData = {\n      sessionId,\n      page,\n      url: url || `/mini-app/${page}`,\n      viewport: {\n        innerHeight: viewport.innerHeight,\n        innerWidth: viewport.innerWidth,\n        telegramHeight: viewport.telegramHeight,\n        telegramStableHeight: viewport.telegramStableHeight,\n        telegramExpanded: viewport.telegramExpanded,\n        calculatedContentHeight: viewport.calculatedContentHeight,\n        actualContentHeight: viewport.actualContentHeight,\n        bottomNavHeight: bottomNavHeight,\n        headerHeight: headerHeight,\n        totalSubtracted: totalSubtracted,\n        availableHeight: availableHeight,\n        difference: viewport.difference,\n        safeBounds: viewport.safeBounds || { top: 0, bottom: 0, left: 0, right: 0 }\n      },\n      device: {\n        userAgent: device.userAgent,\n        platform: device.platform || detectPlatform(device.userAgent),\n        browser: device.browser || detectBrowser(device.userAgent),\n        devicePixelRatio: device.devicePixelRatio || 1,\n        orientation: device.orientation || 'portrait',\n        screen: device.screen\n      },\n      telegram: {\n        isAvailable: telegram?.isAvailable || false,\n        version: telegram?.version,\n        platform: telegram?.platform,\n        colorScheme: telegram?.colorScheme,\n        isVerticalSwipesEnabled: telegram?.isVerticalSwipesEnabled,\n        headerColor: telegram?.headerColor,\n        backgroundColor: telegram?.backgroundColor\n      },\n      problem: {\n        type: problemType,\n        severity: severity,\n        description: problem.description || generateProblemDescription(viewport, problemType),\n        scrollTop: problem.scrollTop || 0,\n        scrollHeight: problem.scrollHeight || 0,\n        clientHeight: problem.clientHeight || 0,\n        // ðŸ”§ ÐÐžÐ’ÐžÐ•: Ð Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð½Ñ‹Ðµ Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¸\n        recommendations: problem.recommendations || [],\n        sizeMismatches: problem.sizeMismatches || {}\n      },\n      debugMode,\n      cssVariables: cssVariables || {},\n      notes,\n      timestamp: timestamp ? new Date(timestamp) : new Date()\n    };\n\n    // ðŸ”§ ÐÐžÐ’ÐžÐ•: Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ñ€Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ ÐµÑÐ»Ð¸ Ð¾Ð½Ð¸ ÐµÑÑ‚ÑŒ\n    if (sizes) {\n      viewportLogData.sizes = {\n        css: sizes.css || {},\n        real: sizes.real || {},\n        comparison: sizes.comparison || {}\n      };\n    }\n\n    if (fixedElements && fixedElements.length > 0) {\n      viewportLogData.fixedElements = fixedElements.slice(0, 20); // ÐžÐ³Ñ€Ð°Ð½Ð¸Ñ‡Ð¸Ð²Ð°ÐµÐ¼ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð´Ð»Ñ ÑÐºÐ¾Ð½Ð¾Ð¼Ð¸Ð¸ Ð¼ÐµÑÑ‚Ð°\n    }\n\n    if (documentMetrics) {\n      viewportLogData.document = documentMetrics;\n    }\n\n    if (content) {\n      viewportLogData.content = content;\n    }\n\n    if (ios && ios.isIOS) {\n      viewportLogData.ios = ios;\n    }\n\n    const viewportLog = new ViewportLog(viewportLogData);\n\n    // ðŸ’¾ Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ð² Ð‘Ð”\n    await viewportLog.save();\n\n    // ðŸ“Š Ð›Ð¾Ð³Ð¸Ñ€ÑƒÐµÐ¼ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾Ðµ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ðµ Ñ Ð´ÐµÑ‚Ð°Ð»ÑŒÐ½Ð¾Ð¹ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÐµÐ¹\n    const saveLogData = {\n      id: viewportLog._id,\n      sessionId: sessionId.substring(0, 8),\n      problemType,\n      severity,\n      difference: viewport.difference\n    };\n\n    // ðŸ”§ ÐÐžÐ’ÐžÐ•: Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ñ‹ Ð°Ð½Ð°Ð»Ð¸Ð·Ð° Ñ€Ð°Ð·Ð¼ÐµÑ€Ð¾Ð²\n    if (sizes?.comparison) {\n      saveLogData.sizeMismatches = {\n        header: sizes.comparison.headerDifference,\n        nav: sizes.comparison.navDifference\n      };\n    }\n\n    logger.info('âœ… [DEBUG] Viewport log saved v2.0:', saveLogData);\n\n    // ðŸš¨ Ð•ÑÐ»Ð¸ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ð° ÑÐµÑ€ÑŒÐµÐ·Ð½Ð°Ñ - Ð»Ð¾Ð³Ð¸Ñ€ÑƒÐµÐ¼ Ñ Ð¿Ð¾Ð²Ñ‹ÑˆÐµÐ½Ð½Ñ‹Ð¼ Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚Ð¾Ð¼\n    if (severity === 'severe') {\n      const severeLogData = {\n        platform: device.platform,\n        page,\n        difference: viewport.difference,\n        userAgent: device.userAgent\n      };\n\n      // ðŸ”§ ÐÐžÐ’ÐžÐ•: Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¾ Ñ€Ð°Ð·Ð¼ÐµÑ€Ð°Ñ… Ð² ÐºÑ€Ð¸Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸Ðµ Ð»Ð¾Ð³Ð¸\n      if (sizes?.real) {\n        severeLogData.realSizes = {\n          header: sizes.real.headerHeight,\n          nav: sizes.real.bottomNavHeight\n        };\n      }\n\n      if (ios?.isIOS) {\n        severeLogData.iOS = true;\n        severeLogData.safeAreaSupport = ios.safeAreaSupport;\n      }\n\n      logger.warn('ðŸš¨ [DEBUG] SEVERE viewport issue detected v2.0:', severeLogData);\n    }\n\n    // âœ… Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ ÑƒÑÐ¿ÐµÑˆÐ½Ñ‹Ð¹ Ð¾Ñ‚Ð²ÐµÑ‚ Ñ Ñ€Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð½Ð¾Ð¹ Ð°Ð½Ð°Ð»Ð¸Ñ‚Ð¸ÐºÐ¾Ð¹\n    const responseData = {\n      success: true,\n      message: 'Viewport data logged successfully with extended diagnostics',\n      logId: viewportLog._id,\n      analysis: {\n        problemType,\n        severity,\n        recommendation: getRecommendation(problemType, viewport, sizes)\n      }\n    };\n\n    // ðŸ”§ ÐÐžÐ’ÐžÐ•: Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð°Ð½Ð°Ð»Ð¸Ð· Ñ€Ð°Ð·Ð¼ÐµÑ€Ð¾Ð² Ð² Ð¾Ñ‚Ð²ÐµÑ‚\n    if (sizes?.comparison) {\n      responseData.analysis.sizeAnalysis = {\n        headerMismatch: sizes.comparison.headerDifference,\n        navMismatch: sizes.comparison.navDifference,\n        totalMismatch: (sizes.comparison.headerDifference || 0) + (sizes.comparison.navDifference || 0)\n      };\n    }\n\n    res.json(responseData);\n\n  } catch (error) {\n    logger.error('âŒ [DEBUG] Failed to log viewport data v2.0:', {\n      error: error.message,\n      stack: error.stack,\n      bodyKeys: Object.keys(req.body),\n      hasExtendedData: !!(req.body.sizes || req.body.fixedElements || req.body.ios)\n    });\n\n    res.status(500).json({\n      success: false,\n      error: 'Failed to log viewport data',\n      details: error.message\n    });\n  }\n});\n\n/**\n * ðŸ“Š GET /api/debug/viewport/stats - Ð¡Ñ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐ° viewport Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼\n * \n * Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ð°Ð½Ð°Ð»Ð¸Ñ‚Ð¸ÐºÑƒ Ð¿Ð¾ ÑÐ¾Ð±Ñ€Ð°Ð½Ð½Ñ‹Ð¼ Ð´Ð°Ð½Ð½Ñ‹Ð¼ viewport\n */\nrouter.get('/viewport/stats', async (req, res) => {\n  try {\n    const { platform, page, limit = 100, days = 7 } = req.query;\n\n    // ðŸ“… Ð¤Ð¸Ð»ÑŒÑ‚Ñ€ Ð¿Ð¾ Ð´Ð°Ñ‚Ðµ\n    const dateFilter = {\n      timestamp: {\n        $gte: new Date(Date.now() - days * 24 * 60 * 60 * 1000)\n      }\n    };\n\n    // ðŸ” Ð”Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ñ„Ð¸Ð»ÑŒÑ‚Ñ€Ñ‹\n    const filters = { ...dateFilter };\n    if (platform) filters['device.platform'] = platform;\n    if (page) filters.page = page;\n\n    // ðŸ“Š ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÑƒ\n    const [\n      totalLogs,\n      problemsByType,\n      problemsByPlatform,\n      problemsByPage,\n      recentProblems,\n      averageMetrics\n    ] = await Promise.all([\n      ViewportLog.countDocuments(filters),\n      \n      ViewportLog.aggregate([\n        { $match: filters },\n        { $group: { _id: '$problem.type', count: { $sum: 1 } } },\n        { $sort: { count: -1 } }\n      ]),\n      \n      ViewportLog.aggregate([\n        { $match: filters },\n        { $group: { _id: '$device.platform', count: { $sum: 1 } } },\n        { $sort: { count: -1 } }\n      ]),\n      \n      ViewportLog.aggregate([\n        { $match: filters },\n        { $group: { _id: '$page', count: { $sum: 1 } } },\n        { $sort: { count: -1 } }\n      ]),\n      \n      ViewportLog.find(filters)\n        .sort({ timestamp: -1 })\n        .limit(parseInt(limit))\n        .select('page device.platform problem.type viewport.difference timestamp sizes.comparison')\n        .lean(),\n        \n      ViewportLog.aggregate([\n        { $match: filters },\n        {\n          $group: {\n            _id: null,\n            avgDifference: { $avg: '$viewport.difference' },\n            avgInnerHeight: { $avg: '$viewport.innerHeight' },\n            avgTelegramHeight: { $avg: '$viewport.telegramHeight' },\n            avgBottomNavHeight: { $avg: '$viewport.bottomNavHeight' },\n            avgHeaderHeight: { $avg: '$viewport.headerHeight' }\n          }\n        }\n      ])\n    ]);\n\n    // ðŸ“ˆ Ð¤Ð¾Ñ€Ð¼Ð¸Ñ€ÑƒÐµÐ¼ Ð¾Ñ‚Ð²ÐµÑ‚\n    const stats = {\n      summary: {\n        totalLogs,\n        period: `${days} days`,\n        platforms: problemsByPlatform.length,\n        pages: problemsByPage.length\n      },\n      problems: {\n        byType: problemsByType,\n        byPlatform: problemsByPlatform,\n        byPage: problemsByPage\n      },\n      metrics: averageMetrics[0] || {},\n      recent: recentProblems\n    };\n\n    logger.info('ðŸ“Š [DEBUG] Stats requested v2.0:', {\n      platform,\n      page,\n      totalLogs,\n      days\n    });\n\n    res.json({\n      success: true,\n      data: stats\n    });\n\n  } catch (error) {\n    logger.error('âŒ [DEBUG] Failed to get viewport stats:', error);\n    \n    res.status(500).json({\n      success: false,\n      error: 'Failed to get viewport statistics',\n      details: error.message\n    });\n  }\n});\n\n/**\n * ðŸ” GET /api/debug/viewport/analysis - Ð”ÐµÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð°Ð½Ð°Ð»Ð¸Ð· Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼\n * \n * Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ð´ÐµÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð°Ð½Ð°Ð»Ð¸Ð· ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ð¾Ð¹ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹ Ð¸Ð»Ð¸ Ñ‚Ð¸Ð¿Ð° Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼\n */\nrouter.get('/viewport/analysis', async (req, res) => {\n  try {\n    const { logId, problemType, platform } = req.query;\n\n    let analysisData;\n\n    if (logId) {\n      // ÐÐ½Ð°Ð»Ð¸Ð· ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ð¾Ð¹ Ð·Ð°Ð¿Ð¸ÑÐ¸\n      analysisData = await ViewportLog.findById(logId).lean();\n      if (!analysisData) {\n        return res.status(404).json({\n          success: false,\n          error: 'Viewport log not found'\n        });\n      }\n    } else {\n      // ÐÐ½Ð°Ð»Ð¸Ð· Ð¿Ð¾ Ñ‚Ð¸Ð¿Ñƒ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹ Ð¸Ð»Ð¸ Ð¿Ð»Ð°Ñ‚Ñ„Ð¾Ñ€Ð¼Ðµ\n      const filters = {};\n      if (problemType) filters['problem.type'] = problemType;\n      if (platform) filters['device.platform'] = platform;\n\n      analysisData = await ViewportLog.aggregate([\n        { $match: filters },\n        {\n          $group: {\n            _id: {\n              platform: '$device.platform',\n              page: '$page',\n              problemType: '$problem.type'\n            },\n            count: { $sum: 1 },\n            avgDifference: { $avg: '$viewport.difference' },\n            minDifference: { $min: '$viewport.difference' },\n            maxDifference: { $max: '$viewport.difference' },\n            avgInnerHeight: { $avg: '$viewport.innerHeight' },\n            avgTelegramHeight: { $avg: '$viewport.telegramHeight' },\n            samples: { $push: '$$ROOT' }\n          }\n        },\n        { $sort: { count: -1 } },\n        { $limit: 20 }\n      ]);\n    }\n\n    res.json({\n      success: true,\n      data: analysisData,\n      timestamp: new Date().toISOString()\n    });\n\n  } catch (error) {\n    logger.error('âŒ [DEBUG] Failed to get viewport analysis:', error);\n    \n    res.status(500).json({\n      success: false,\n      error: 'Failed to get viewport analysis',\n      details: error.message\n    });\n  }\n});\n\n/**\n * ðŸ—‘ï¸ DELETE /api/debug/viewport/clear - ÐžÑ‡Ð¸ÑÑ‚ÐºÐ° ÑÑ‚Ð°Ñ€Ñ‹Ñ… Ð»Ð¾Ð³Ð¾Ð²\n * \n * Ð£Ð´Ð°Ð»ÑÐµÑ‚ ÑÑ‚Ð°Ñ€Ñ‹Ðµ Ð·Ð°Ð¿Ð¸ÑÐ¸ viewport Ð»Ð¾Ð³Ð¾Ð² Ð´Ð»Ñ ÑÐºÐ¾Ð½Ð¾Ð¼Ð¸Ð¸ Ð¼ÐµÑÑ‚Ð°\n */\nrouter.delete('/viewport/clear', async (req, res) => {\n  try {\n    const { days = 30 } = req.query;\n    \n    const cutoffDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);\n    \n    const result = await ViewportLog.deleteMany({\n      timestamp: { $lt: cutoffDate }\n    });\n\n    logger.info('ðŸ—‘ï¸ [DEBUG] Viewport logs cleaned:', {\n      deletedCount: result.deletedCount,\n      cutoffDate,\n      days\n    });\n\n    res.json({\n      success: true,\n      message: `Deleted ${result.deletedCount} old viewport logs`,\n      deletedCount: result.deletedCount,\n      cutoffDate\n    });\n\n  } catch (error) {\n    logger.error('âŒ [DEBUG] Failed to clear viewport logs:', error);\n    \n    res.status(500).json({\n      success: false,\n      error: 'Failed to clear viewport logs',\n      details: error.message\n    });\n  }\n});\n\n// ===========================================\n// ðŸ› ï¸ Ð’Ð¡ÐŸÐžÐœÐžÐ“ÐÐ¢Ð•Ð›Ð¬ÐÐ«Ð• Ð¤Ð£ÐÐšÐ¦Ð˜Ð˜\n// ===========================================\n\n/**\n * ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»Ð¸Ñ‚ÑŒ Ñ‚Ð¸Ð¿ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹ viewport\n */\nfunction determineProblemType(viewport, problem) {\n  const diff = viewport.difference;\n  \n  if (problem.type) return problem.type;\n  \n  if (diff > 10) return 'empty_space_bottom';\n  if (diff < -10) return 'content_overflow';\n  if (Math.abs(diff) < 10) return 'height_mismatch';\n  \n  return 'scroll_issue';\n}\n\n/**\n * ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»Ð¸Ñ‚ÑŒ ÑÐµÑ€ÑŒÐµÐ·Ð½Ð¾ÑÑ‚ÑŒ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹\n */\nfunction determineSeverity(difference) {\n  const abs = Math.abs(difference);\n  \n  if (abs < 10) return 'minor';\n  if (abs < 50) return 'moderate';\n  return 'severe';\n}\n\n/**\n * ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»Ð¸Ñ‚ÑŒ Ð¿Ð»Ð°Ñ‚Ñ„Ð¾Ñ€Ð¼Ñƒ Ð¿Ð¾ User Agent\n */\nfunction detectPlatform(userAgent) {\n  if (/iPhone|iPad|iPod/i.test(userAgent)) return 'iOS';\n  if (/Android/i.test(userAgent)) return 'Android';\n  if (/Windows|Mac|Linux/i.test(userAgent)) return 'Desktop';\n  return 'Unknown';\n}\n\n/**\n * ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»Ð¸Ñ‚ÑŒ Ð±Ñ€Ð°ÑƒÐ·ÐµÑ€ Ð¿Ð¾ User Agent\n */\nfunction detectBrowser(userAgent) {\n  if (/TelegramWebApp/i.test(userAgent)) return 'Telegram';\n  if (/Chrome/i.test(userAgent)) return 'Chrome';\n  if (/Safari/i.test(userAgent)) return 'Safari';\n  if (/Firefox/i.test(userAgent)) return 'Firefox';\n  return 'Unknown';\n}\n\n/**\n * Ð¡Ð³ÐµÐ½ÐµÑ€Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹\n */\nfunction generateProblemDescription(viewport, problemType) {\n  const diff = viewport.difference;\n  \n  switch (problemType) {\n    case 'empty_space_bottom':\n      return `Empty space at bottom: ${diff}px gap between content and navigation`;\n    case 'content_overflow':\n      return `Content overflow: ${Math.abs(diff)}px content hidden below viewport`;\n    case 'height_mismatch':\n      return `Height calculation mismatch: ${diff}px difference in expected vs actual`;\n    case 'scroll_issue':\n      return `Scroll behavior issue with ${diff}px viewport difference`;\n    default:\n      return `Viewport issue: ${diff}px difference detected`;\n  }\n}\n\n/**\n * ðŸ”§ ÐžÐ‘ÐÐžÐ’Ð›Ð•ÐÐž: ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸ÑŽ Ð¿Ð¾ Ð¸ÑÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸ÑŽ Ñ ÑƒÑ‡ÐµÑ‚Ð¾Ð¼ Ñ€Ð°Ð·Ð¼ÐµÑ€Ð¾Ð²\n */\nfunction getRecommendation(problemType, viewport, sizes) {\n  let recommendations = [];\n  \n  // Ð‘Ð°Ð·Ð¾Ð²Ñ‹Ðµ Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¸ Ð¿Ð¾ Ñ‚Ð¸Ð¿Ñƒ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹\n  switch (problemType) {\n    case 'empty_space_bottom':\n      recommendations.push('Consider reducing bottom padding or adjusting content height calculation');\n      break;\n    case 'content_overflow':\n      recommendations.push('Increase content container height or enable scrolling');\n      break;\n    case 'height_mismatch':\n      recommendations.push('Review CSS calc() formulas and Telegram viewport integration');\n      break;\n    case 'scroll_issue':\n      recommendations.push('Check scroll container configuration and overflow settings');\n      break;\n    default:\n      recommendations.push('Review viewport height calculation logic');\n  }\n  \n  // ðŸ”§ ÐÐžÐ’ÐžÐ•: Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¸ Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ Ð°Ð½Ð°Ð»Ð¸Ð·Ð° Ñ€Ð°Ð·Ð¼ÐµÑ€Ð¾Ð²\n  if (sizes?.comparison) {\n    const headerDiff = sizes.comparison.headerDifference || 0;\n    const navDiff = sizes.comparison.navDifference || 0;\n    \n    if (Math.abs(headerDiff) > 5) {\n      recommendations.push(`Update --header-height CSS variable from ${sizes.css?.headerHeight}px to ${sizes.real?.headerHeight}px`);\n    }\n    \n    if (Math.abs(navDiff) > 5) {\n      recommendations.push(`Update --bottom-nav-height CSS variable from ${sizes.css?.bottomNavHeight}px to ${sizes.real?.bottomNavHeight}px`);\n    }\n    \n    if (Math.abs(headerDiff) > 5 || Math.abs(navDiff) > 5) {\n      recommendations.push('CSS variables do not match real element sizes - this is likely the root cause');\n    }\n  }\n  \n  return recommendations.join('. ');\n}\n\nmodule.exports = router;